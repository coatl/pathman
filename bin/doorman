#!/usr/bin/env ruby

class Doorman
  def initialize 
    readconfig
  end

  SCAN_SUBDIRS={ 'src'=>'LIBRARY_PATH', 'include'=>'CPATH', 
                 'lib'=>'RUBYLIB', 'ext'=>'RUBYLIB', 
                 'test'=>'TESTDIRS', 'bin'=>'PATH' 
               }
  #CPATH and LIBRARY_PATH are somewhat specific to unix/gcc ??
  #I believe something else (INCLUDE and LIB?) are used instead in the MS toolchain.
  #envs to update: PATH,LIBRARY_PATH,CPATH,RUBYLIB,TESTDIRS

  #return true if a makefile exists or can be made
  #must be called in a subdir
  def find_makefile
  saw=nil #this to ensure loop exits
  loop do
    return true if File.exist? 'Makefile' or File.exist? 'makefile'
    if File.exist? './configure'
      return false if saw==:configure
      saw=:configure
      system './configure' #maybe should pass options here...?
      next
    elsif File.exist? 'configure.in' 
      return false if saw
      saw=:autoconf
      system 'autoconf'
      next
    else return false
    end
  end
  end

  def othervars name
    return find_doorman_dir if name=="pwd"
    nil #for now
  end

  def readconfig 
    dir=find_doorman_dir
    prefix=''
    prefix+='.'
    prefix='' if prefix=='.'
    lines=File.readlines(dir+'/doorman.dm') rescue []
    lines.reject!{|line| /^\s*(\#.*)?$/===line} #rm comments and blanks
    kv=lines.map!{|line| line.split('=',2) }
    kv.map!{|(k,v)| #every k needs prefix prepended unless has one already
      k=prefix+k unless k['.']
      [k,v]
    }
    kv.flatten!
    kv.each{|frag|
      frag.gsub!(/\$\(?(\w+)\)?/){ENV[$1]||othervars($1)} #substitute env vars
      frag.sub!(/\A\s*(.*[^\s])\s*\n?\Z/,"\\1")#remove leading/trailing ws
    }
    @config=Hash[*kv]
    @include=@config['include'].split(' ') rescue []
    @exclude=@config['exclude'].split(' ') rescue []

    #todo for config file:
    #doorman.dm in subdirs?
    #configuration points:
    #  global: envvars
    #  per project: test/make/clean cmd, ./configure options
    #  v per project: SCAN_SUBDIRS
    #  v global: build order(dirs to include), dirs to exclude
    #v should be able to use env vars (and others?) in conf items
    #v virtual subdirs
  end

  SUBCOMMANDS=%w[make clean test generate invoke]
  def main(mode,d=Dir.pwd)
    mode||="invoke"
    return( send mode,d ) if SUBCOMMANDS.include? mode
    fail "unknown subcommand"
  end

  def insubdir d
    !SCAN_SUBDIRS.keys.select{|dir| File.directory?(d+"/"+dir)}.empty?
  end

  def subdirs d
    result=@include.map{|dir| d+'/'+dir} + 
      Dir[d+"/*"].select{|dir| 
        File.directory?( dir ) and 
          !@exclude.include?( File.basename( dir ) )
      }
    result.uniq!
    result
  end

  def doorman_home d
    ENV['DMHOME'] or File.dirname d 
  end

  def make d
    unless insubdir d
      subdirs(d).each{|subdir| make subdir }
      #what about build order? has to be configured
    else
      setup_env( doorman_home( d ) )
      Dir.chdir d

      huh #shouldn't do anything if make of this dir happened already on this run
      #(prevents an infinite loop with make_predecessors_of)

      #build dependencies in toplevel dir first
      make_predecessors_of( File.dirname(d.chomp('/')), d )

      #scan for configure.in, configure, Makefile, makefile, Rakefile, rakefile, build.sh in proj dirs, 
      #then issue the appropriate build cmd(s) for that script
      if find_makefile
        system "make"
        huh unless $?.exitstatus==0
      elsif File.exist? 'Rakefile' or File.exist? 'rakefile'
        system "rake"
        huh unless $?.exitstatus==0
      elsif File.exist? "./build.sh"
        system "./build.sh"
        #also try build.cmd/bat on windows?
        huh unless $?.exitstatus==0
      else huh
      end
    end
  end

  def make_predecessors_of d, upto
    subdirs(d).each{|subdir| 
      break if subdir==upto
      make subdir 
    }
    #what about build order? has to be configured
  end


  def clean d
    unless insubdir d
      subdirs(d).each{|subdir| clean subdir }
    else
      setup_env( doorman_home( d ) )
      Dir.chdir d

      huh
      if find_makefile
        system "make clean"
        huh unless $?.exitstatus==0
      elsif File.exist? 'Rakefile' or File.exist? 'rakefile'
        system "rake clean"
        huh unless $?.exitstatus==0
      elsif File.exist? "./clean.sh"
        system "./clean.sh"
        huh unless $?.exitstatus==0
        #also try clean.cmd/bat on windows?
      else huh
      end
    end
  end

  def test d
    make d  #maybe make first? and make dependencies

    unless insubdir d
      subdirs(d).each{|subdir| test subdir }
    else
    Dir.chdir d

    #try various places the tests might be
    try=[%w[test/test.sh], %w[ruby test/test.rb], 
         %w[test/test_all.sh], %w[ruby test/test_all.rb]
    ]
    #also try test(_all)?.cmd/bat on windows?

    try=try.find{|try| File.exist? try.last }
    if try
      system try 
        huh unless $?.exitstatus==0
    elsif File.exist? 'Rakefile' or File.exist? 'rakefile' 
      system 'rake test'
        huh unless $?.exitstatus==0
    elsif File.exist? 'Makefile' or File.exist? 'makefile'
      system 'make test'
        huh unless $?.exitstatus==0
    else huh
    end
    end
  end
  

  #generate a doorman.dm file with default settings for the user to edit
  def generate d
    if insubdir d
      Dir.chdir d
      huh
    else
      huh
    end
  end

  def setup_env d
    #do nothing if called already
    return @setup_env if defined? @setup_env
    
    fail if insubdir d

    changes={} #log of envvars changed so we can print it out

    #update env vars depending on what sub-sub-dirs are found
    #keep a log of what changed in changes
    subdirs(d).each{|subdir|
      SCAN_SUBDIRS.each_pair{|sdir,envs|
        scanning= @config[File.basename(subdir)+'.'+sdir] ||
                  subdir+"/"+sdir
        if ( File.directory?( scanning ) rescue nil)
          Array(envs).each{|env|
            old=ENV[env]
            if old #envvar already exists, update
              new=old+File::PATH_SEPARATOR+scanning
              changes[env]||="$#{env}"+File::PATH_SEPARATOR
            else #create new envvar
              new=scanning
              changes[env]||=''
            end
            changes[env]<<scanning+File::PATH_SEPARATOR
            ENV[env]=new
          }
        end
      }
    }

    fail "doorman reinvoked in a doorman session!" if ENV['DMHOME'] and ENV['DMHOME']!=''
    ENV['DMHOME']=Dir.pwd
 
    return @setup_env=changes
  end

  def find_doorman_dir dir=Dir.pwd
    #search up the dir tree for dir that contains doorman.dm
    dir=File.dirname dir until File.exist?(dir+"/doorman.dm")
    dir
  end

  def invoke ignored  #no args; set env vars and shell out
    dir=origdir=Dir.pwd
    dir=find_doorman_dir dir

    #now cd to it  
    Dir.chdir dir
      changes=setup_env dir
    Dir.chdir origdir
  
    #print out what was changed
    puts
    puts "DMHOME=#{dir}"
    changes.each_pair{|env,val| 
      val=val.chomp File::PATH_SEPARATOR #rm trailing sep left by setup_env

      #compress out instances of $DMHOME
      val.gsub!(/(\A|#{File::PATH_SEPARATOR})(#{dir})/,'\\1$DMHOME')

      #keep line from being longer than ~50 chars
      #1 while val.gsub!(/^([^\n]{60,}:)((?!\\\n).*)$/,"\\1\\\\\n\\2")
      lastsplit=i=0
      while i=val.index(File::PATH_SEPARATOR,i)
        if i-lastsplit>50
          val[i+1,0]="\\\n"
          lastsplit=i
        end
        i+=1
      end

      puts env+"="+val 
    }
    puts

    exec "bash"  #should use $SHELL here?
    #should call CMD.EXE on windows....
  end
end

Doorman.new.main ARGV[0] if __FILE__==$0

#todo:
#v detect re-doorman while already in a doorman env
#v DMHOME env var?
#need a -n option, like make
#--verbose/--quiet ??
